import chromadb
from chromadb.config import Settings
import openai
import yaml
from time import time, sleep
from uuid import uuid4
import os
from dotenv import load_dotenv


def save_yaml(filepath, data):
    with open(filepath, 'w', encoding='utf-8') as file:
        yaml.dump(data, file, allow_unicode=True)

def save_file(filepath, content):
    with open(filepath, 'w', encoding='utf-8') as outfile:
        outfile.write(content)

def open_file(filepath):
    with open(filepath, 'r', encoding='utf-8', errors='ignore') as infile:
        return infile.read()

def chatbot(messages, model="gpt-4", temperature=0):
    """
    Function to interact with the OpenAI chatbot model.

    Parameters:
    - messages (list): List of message objects for the chatbot conversation.
    - model (str): OpenAI model to use for generating responses. Default is 'gpt-4'.
    - temperature (float): Controls the randomness of the generated text. Default is 0.

    Returns:
    - text (str): The text generated by the chatbot.
    """
    # Set maximum retries for the API call
    max_retry = 7
    # Initialize retry counter
    retry = 0
    
    while True:
        try:
            # Call OpenAI API to generate chatbot's response
            response = openai.ChatCompletion.create(model=model, messages=messages, temperature=temperature)
            # Extract the text content from the API response
            text = response['choices'][0]['message']['content']
            
            # Debugging: Save the conversation log for analysis
            debug_object = [i['content'] for i in messages]
            debug_object.append(text)
            save_yaml('api_logs/convo_%s.yaml' % time(), debug_object)
            
            # Check token count, remove oldest message if limit exceeded
            if response['usage']['total_tokens'] >= 7000:
                a = messages.pop(1)
            
            return text
        
        except Exception as oops:
            # Handle exceptions
            print(f'\n\nError communicating with OpenAI: "{oops}"')
            
            # If the exception is due to maximum context length, remove the oldest message
            if 'maximum context length' in str(oops):
                a = messages.pop(1)
                print('\n\n DEBUG: Trimming oldest message')
                continue
            
            # Increment the retry counter
            retry += 1
            
            # Exit if retries exceed the maximum limit
            if retry >= max_retry:
                print(f"\n\nExiting due to excessive errors in API: {oops}")
                exit(1)
            
            # Wait for an exponential backoff time before retrying
            print(f'\n\nRetrying in {2 ** (retry - 1) * 5} seconds...')
            sleep(2 ** (retry - 1) * 5)

def get_user_input(user_messages, all_messages, conversation):
    """
    Get input from the user and update relevant data structures.
    
    Parameters:
    - user_messages (list): A list to store the messages from the user.
    - all_messages (list): A list to store all the messages in the conversation.
    - conversation (list): A list of dictionaries to store the role and content of each message.

    Returns:
    None
    """
    # Get user input
    text = input('\n\nUSER: ')
    
    # Append the user's message to the list of user messages
    user_messages.append(text)
    
    # Append the user's message to the list of all messages
    formatted_text = f'USER: {text}'
    all_messages.append(formatted_text)
    
    # Append the role and content to the conversation list
    conversation.append({'role': 'user', 'content': text})
    
    # Save the user's message to a file
    filename = f'chat_logs/chat_{time()}_user.txt'
    save_file(filename, text)

def update_knowledge_base(collection, main_scratchpad, chatbot, open_file, save_file):
    """
    Update the knowledge base with new or updated articles.
    
    Parameters:
    - collection: The database collection where the KB is stored.
    - main_scratchpad: The content to be added or updated in the KB.
    - chatbot: The function that generates an article for the KB.
    - open_file: Function to open a file and read its content.
    - save_file: Function to save logs.

    Returns:
    - None
    """
    print('\n\nUpdating KB...')
    
    # Check if the KB is empty
    if collection.count() == 0:
        kb_convo = [{'role': 'system', 'content': open_file('system_instantiate_new_kb.txt')},
                    {'role': 'user', 'content': main_scratchpad}]
        article = chatbot(kb_convo)
        new_id = str(uuid4())
        collection.add(documents=[article], ids=[new_id])
        save_file(f'db_logs/log_{time()}_add.txt', f'Added document {new_id}:\n{article}')

    else:
        results = collection.query(query_texts=[main_scratchpad], n_results=1)
        kb = results['documents'][0][0]
        kb_id = results['ids'][0][0]

        kb_convo = [{'role': 'system', 'content': open_file('system_update_existing_kb.txt').replace('<<KB>>', kb)},
                    {'role': 'user', 'content': main_scratchpad}]
        article = chatbot(kb_convo)
        collection.update(ids=[kb_id], documents=[article])
        save_file(f'db_logs/log_{time()}_update.txt', f'Updated document {kb_id}:\n{article}')

        # Check if the article is too long and needs to be split
        kb_len = len(article.split(' '))
        if kb_len > 1000:
            kb_convo = [{'role': 'system', 'content': open_file('system_split_kb.txt')},
                        {'role': 'user', 'content': article}]
            articles = chatbot(kb_convo).split('ARTICLE 2:')
            a1 = articles[0].replace('ARTICLE 1:', '').strip()
            a2 = articles[1].strip()
            collection.update(ids=[kb_id], documents=[a1])
            new_id = str(uuid4())
            collection.add(documents=[a2], ids=[new_id])
            save_file(f'db_logs/log_{time()}_split.txt', f'Split document {kb_id}, added {new_id}:\n{a1}\n\n{a2}')

def update_system_with_kb(collection, main_scratchpad, conversation):
    """
    Update the system with information from the Knowledge Base (KB) and the current user profile.
    
    Parameters:
    - collection: Database collection object for querying KB articles.
    - main_scratchpad: Text to be queried against the KB collection.
    - conversation: List to hold the conversation, where the first element's 'content' key will be updated.
    
    Returns:
    - None: Updates the conversation list in-place.
    """
    
    # Read the current user profile from a file.
    current_profile = open_file('user_profile.txt')
    
    # Initialize KB as empty.
    kb = 'No KB articles yet'
    
    # If there are KB articles in the collection, query the main scratchpad text.
    if collection.count() > 0:
        results = collection.query(query_texts=[main_scratchpad], n_results=1)
        kb = results['documents'][0][0]
        # Uncomment the line below for debugging.
        # print('\n\nDEBUG: Found results %s' % results)
    
    # Read and update the default system information.
    default_system = open_file('Persona\Emily_v1.1.md').replace('<<PROFILE>>', current_profile).replace('<<KB>>', kb)
    
    # Uncomment the line below for debugging.
    # print('SYSTEM: %s' % default_system)
    
    # Update the conversation list.
    conversation[0]['content'] = default_system

def update_user_profile(current_profile, user_scratchpad, open_file, save_file, chatbot):
    """
    Updates the user profile by generating a conversation between system and user,
    and then saving the new profile into a file.

    Parameters:
    - current_profile (str): The current user profile in text form.
    - user_scratchpad (str): User-provided content for the profile update.
    - open_file (function): Function to open and read a file.
    - save_file (function): Function to save content into a file.
    - chatbot (function): Function that simulates the chatbot interaction.

    Returns:
    None
    """
    print('\n\nUpdating user profile...')
    # Calculate the length of the current profile in terms of words
    profile_length = len(current_profile.split(' '))
  
    # Initialize a list to store the conversation between the system and the user
    profile_conversation = list()
  
    # Append system's message to the conversation
    system_content = open_file('system_update_user_profile.txt').replace('<<UPD>>', current_profile).replace('<<WORDS>>', str(profile_length))
    profile_conversation.append({'role': 'system', 'content': system_content})
  
    # Append user's message to the conversation
    profile_conversation.append({'role': 'user', 'content': user_scratchpad})
  
    # Generate a new profile using the chatbot function
    profile = chatbot(profile_conversation)
  
    # Save the new profile into a file
    save_file('user_profile.txt', profile)



def main():
    load_dotenv()
    # instantiate ChromaDB
    persist_directory = "chromadb"
    # chroma_client = chromadb.PersistentClient(Settings(persist_directory=persist_directory,chroma_db_impl="duckdb+parquet",))
    chroma_client = chromadb.PersistentClient(path=persist_directory)
    collection = chroma_client.get_or_create_collection(name="knowledge_base")


    # instantiate chatbot
    openai.api_key = os.getenv("OPENAI_API_KEY")
    conversation = list()
    conversation.append({'role': 'system', 'content': open_file('Persona\Emily_v1.1.md')})
    user_messages = list()
    all_messages = list()
    
    while True:
        # get user input
        get_user_input(user_messages, all_messages, conversation)


        # update main scratchpad
        if len(all_messages) > 5:
            all_messages.pop(0)
        main_scratchpad = '\n\n'.join(all_messages).strip()


        # search KB, update default system
        update_system_with_kb(collection, main_scratchpad, conversation)
        current_profile = update_system_with_kb(collection, main_scratchpad, conversation)
 

        # generate a response
        response = chatbot(conversation)
        save_file('chat_logs/chat_%s_chatbot.txt' % time(), response)
        conversation.append({'role': 'assistant', 'content': response})
        all_messages.append('CHATBOT: %s' % response)
        print('\n\nCHATBOT: %s' % response)


        # update user scratchpad
        if len(user_messages) > 3:
            user_messages.pop(0)
        user_scratchpad = '\n'.join(user_messages).strip()


        # update user profile
        update_user_profile(current_profile, user_scratchpad, open_file, save_file, chatbot)


        # update main scratchpad
        if len(all_messages) > 5:
            all_messages.pop(0)
        main_scratchpad = '\n\n'.join(all_messages).strip()


        # Update the knowledge base
        print('\n\nUpdating KB...')
        update_knowledge_base(collection, main_scratchpad, chatbot, open_file, save_file)


if __name__ == '__main__':
    main()

        
